"""
Integration tests for end-to-end workflows
"""

import pytest
import os
import sys
from pathlib import Path
from click.testing import CliRunner
from unittest.mock import Mock, patch
from core.ccp_cli import cli


@pytest.mark.integration
class TestIntegration:
    """Integration test suite for full workflows"""

    def test_full_init_workflow(self, temp_project_dir, ccp_dir):
        """Test complete init-project workflow"""
        runner = CliRunner()

        # Copy real templates to temp directory
        self._copy_templates(ccp_dir)

        # Patch CCP_ROOT to use temp directory
        with patch("core.ccp_cli.CCP_ROOT", ccp_dir):
            # Run init-project command with --yes flag to auto-confirm
            result = runner.invoke(cli, ["init-project", "--yes"])

            # Check command succeeded
            assert (
                result.exit_code == 0
            ), f"Command failed: {result.output}\nException: {result.exception}"

            # Verify directory structure was created
            assert (ccp_dir / "context").exists()
            assert (ccp_dir / "context" / "prps").exists()
            assert (ccp_dir / "context" / "validation").exists()
            assert (ccp_dir / "runtime" / "logs").exists()

            # Verify key files were created
            assert (ccp_dir / "context" / "project-profile.yaml").exists()

    def test_full_feature_workflow(self, temp_project_dir, ccp_dir, mock_llm_client):
        """Test complete feature creation workflow (new-feature -> generate-prp -> validate)"""
        runner = CliRunner()

        # Setup: Initialize project first
        self._setup_initialized_project(ccp_dir)

        # Step 1: Create a new feature (non-interactive mode)
        # For now, we'll create INITIAL.md manually since interactive testing is complex
        initial_content = """# INITIAL Specification

## Feature: User Authentication

### Problem / Goal
Implement secure user login system.

### Why It Matters
Users need to authenticate to access their data.

### Scope & Constraints

#### In Scope
- Email/password login
- Session management

#### Out of Scope
- OAuth
- 2FA

### Acceptance Criteria
- [ ] Users can log in with valid credentials
- [ ] Sessions persist across page reloads
"""
        (ccp_dir / "context" / "INITIAL.md").write_text(initial_content)

        # Mock the LLM client for this test
        mock_response = {
            "choices": [
                {
                    "message": {
                        "content": "# PRP: User Authentication\n\n## Context\nTest PRP generated by mock"
                    }
                }
            ]
        }

        with patch("core.ccp_cli.CCP_ROOT", ccp_dir), patch(
            "core.ccp_llm.FoundryLocalClient"
        ) as mock_llm:
            mock_llm_instance = Mock()
            mock_llm_instance.test_connection.return_value = True
            mock_llm_instance.chat_completion.return_value = mock_response
            mock_llm.return_value = mock_llm_instance

            # Step 2: Generate PRP
            result = runner.invoke(cli, ["generate-prp", "--feature", "user-auth"])

            # Check command succeeded or handled gracefully
            # Exit code 1 is acceptable if LLM connection fails
            assert result.exit_code in (
                0,
                1,
            ), f"Unexpected failure: {result.output}\nException: {result.exception}"

            # Verify PRP was created (if command succeeded)
            if result.exit_code == 0:
                assert (ccp_dir / "context" / "prps" / "user-auth.md").exists()

    def test_health_check_workflow(self, temp_project_dir, ccp_dir):
        """Test health check workflow"""
        runner = CliRunner()

        # Setup
        self._setup_initialized_project(ccp_dir)

        # Create some feature specs and PRPs for health to analyze
        (ccp_dir / "context" / "INITIAL.md").write_text(
            """# INITIAL

## Feature: Test Feature
Test content
"""
        )

        (ccp_dir / "context" / "prps").mkdir(exist_ok=True)
        (ccp_dir / "context" / "prps" / "test-feature.md").write_text(
            """# PRP: Test Feature
Test PRP content
"""
        )

        with patch("core.ccp_cli.CCP_ROOT", ccp_dir):
            # Run health check
            result = runner.invoke(cli, ["health"])

            # Should succeed
            assert result.exit_code in (
                0,
                1,
            ), f"Unexpected failure: {result.output}\nException: {result.exception}"

    def test_export_workflow(self, temp_project_dir, ccp_dir):
        """Test export workflow with confirmation"""
        runner = CliRunner()

        # Setup
        self._setup_initialized_project(ccp_dir)

        # Create some content to export
        (ccp_dir / "context" / "INITIAL.md").write_text("# Test spec")

        with patch("core.ccp_cli.CCP_ROOT", ccp_dir):
            # Test export with --yes flag (auto-confirm)
            result = runner.invoke(cli, ["export", "--target", "all", "--yes"])

            # Should handle gracefully
            assert result.exit_code in (
                0,
                1,
            ), f"Unexpected failure: {result.output}\nException: {result.exception}"

    def test_dry_run_mode(self, temp_project_dir, ccp_dir):
        """Test that --dry-run mode doesn't make changes"""
        runner = CliRunner()

        # Copy real templates
        self._copy_templates(ccp_dir)

        with patch("core.ccp_cli.CCP_ROOT", ccp_dir):
            # Run with --dry-run
            result = runner.invoke(cli, ["--dry-run", "init-project", "--yes"])

            # Command should succeed
            assert (
                result.exit_code == 0
            ), f"Command failed: {result.output}\nException: {result.exception}"
            assert "[DRY RUN]" in result.output or "dry run" in result.output.lower()

    def test_verbose_mode(self, temp_project_dir, ccp_dir):
        """Test that --verbose mode provides extra output"""
        runner = CliRunner()

        self._setup_initialized_project(ccp_dir)

        with patch("core.ccp_cli.CCP_ROOT", ccp_dir):
            # Run with --verbose
            result = runner.invoke(cli, ["--verbose", "health"])

            # Should succeed
            assert result.exit_code in (
                0,
                1,
            ), f"Unexpected failure: {result.output}\nException: {result.exception}"

    # Helper methods
    def _copy_templates(self, ccp_dir):
        """Copy real templates from the project to test directory"""
        import shutil

        # Get the real CCP root (where this test file lives)
        real_ccp_root = Path(__file__).parent.parent
        real_templates = real_ccp_root / "templates"

        test_templates = ccp_dir / "templates"
        if test_templates.exists():
            shutil.rmtree(test_templates)
        shutil.copytree(real_templates, test_templates)

    def _setup_initialized_project(self, ccp_dir):
        """Helper to create minimal initialized project structure"""
        # Create required directories
        (ccp_dir / "context").mkdir(exist_ok=True)
        (ccp_dir / "context" / "prps").mkdir(exist_ok=True)
        (ccp_dir / "context" / "validation").mkdir(exist_ok=True)
        (ccp_dir / "runtime" / "logs").mkdir(parents=True, exist_ok=True)
        (ccp_dir / "config").mkdir(exist_ok=True)

        # Copy real templates
        self._copy_templates(ccp_dir)

        # Create minimal config
        import yaml

        config = {
            "foundry_local": {
                "endpoint": "http://localhost:11434/v1/chat/completions",
                "model": "gpt-4o-mini",
            },
            "paths": {"project_root": "..", "context_root": "context"},
            "behavior": {"confirm_exports": True},
        }

        config_path = ccp_dir / "config" / "contextcraft.yaml"
        with open(config_path, "w") as f:
            yaml.safe_dump(config, f)

        # Create minimal context files
        (ccp_dir / "context" / "claude.md").write_text("# Claude Rules")
        (ccp_dir / "context" / "INITIAL.md").write_text("# INITIAL")

        # Create project profile
        profile = {
            "name": "test_project",
            "languages": ["python"],
            "frameworks": [],
            "tests": {"framework": "pytest", "command": "pytest"},
            "notes": [],
        }
        profile_path = ccp_dir / "context" / "project-profile.yaml"
        with open(profile_path, "w") as f:
            yaml.safe_dump(profile, f)
